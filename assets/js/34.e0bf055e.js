(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{436:function(t,v,a){"use strict";a.r(v);var e=a(34),s=Object(e.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"var、let、const"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#var、let、const"}},[t._v("#")]),t._v(" var、let、const")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#var"}},[t._v("var")])]),a("li",[a("a",{attrs:{href:"#let"}},[t._v("let")])]),a("li",[a("a",{attrs:{href:"#const"}},[t._v("const")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"var"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#var"}},[t._v("#")]),t._v(" var")]),t._v(" "),a("p",[t._v("var声明的变量未初使化会自动保存一个特殊的值undefined")]),t._v(" "),a("p",[t._v("var定义的变量存在变量提升")]),t._v(" "),a("p",[t._v("在函数内定义变量时省略var操作符，可以创建一个全局变量：")]),t._v(" "),a("p",[t._v("使用var操作符定义的变量会成为包含他的函数的局部变量，比如在一个函数中使用var定义了一个变量，该变量会在函数退出时被销毁。\n如果一个变量保存了字符串类型，在重写变量值的时候最好不要更改数据的类型，仅管这是允许的。")]),t._v(" "),a("p",[t._v("如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：")]),t._v(" "),a("p",[t._v('var message = "hi",found = false, age = 29;')]),t._v(" "),a("p",[t._v("在严格模式下，不能定义名为eval和arguments的变量，否则会导致语法错误。")]),t._v(" "),a("h2",{attrs:{id:"let"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let"}},[t._v("#")]),t._v(" let")]),t._v(" "),a("p",[t._v("let为JS新增了块级作用域")]),t._v(" "),a("p",[t._v("let声明的范围是块作用域，而var声明的范围是函数作用域。")]),t._v(" "),a("p",[t._v("let声明的变量，只在let命令所在的代码块内有效。")]),t._v(" "),a("p",[t._v("let不允许在相同作用域内，重复声明同一个变量。")]),t._v(" "),a("p",[t._v("let 声名的变量不存在变量提升，而是存在暂时性死区")]),t._v(" "),a("p",[t._v("let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）。")]),t._v(" "),a("p",[t._v("不能使用let进行条件式声明")]),t._v(" "),a("p",[t._v("for 循环语句中使用let声名变量会有意想不到的效果")]),t._v(" "),a("h2",{attrs:{id:"const"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#const"}},[t._v("#")]),t._v(" const")]),t._v(" "),a("p",[t._v("const声明一个只读的常量。一旦声明，常量的值就不能改变\nconst PI = 3.1415;\nPI // 3.1415\nPI = 3;\n// TypeError: Assignment to constant variable.")]),t._v(" "),a("p",[t._v("上面代码表明改变常量的值会报错。")]),t._v(" "),a("p",[t._v("const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。")]),t._v(" "),a("p",[t._v("const的作用域与let命令相同：只在声明所在的块级作用域内有效。")]),t._v(" "),a("p",[t._v("const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。")]),t._v(" "),a("p",[t._v("const声明的常量，也与let一样不可重复声明")])])}),[],!1,null,null,null);v.default=s.exports}}]);